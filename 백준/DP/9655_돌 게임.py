# https://www.acmicpc.net/problem/9655

# 나의 풀이 (Python3 76ms)
cnt = 0

n = int(input())

cnt += n // 3                                       # 3으로 나눈 몫만큼 카운팅 (3을 빼줌)
cnt += n % 3                                        # 3으로 나눈 나머지만큼 1씩 빼기

if cnt % 2 == 0:                                    # 상근이가 먼저 시작하므로 창영이는 짝수 턴
    print('CY')
else:
    print('SK')                                     # 상근이는 홀수 턴

# 다른 사람의 풀이 (시간은 동일)
print(int(input()) % 2 and 'SK' or 'CY')            # 세상에... 이런 규칙이...

'''
회고 / TIL
- 나름 76ms로 쉽게 풀었다고 생각했으나...
- 내 풀이는 3이나 1이 언제 나오는지는 상관없이, 조합적으로 생각했음. 
- 어쨌든 게임이 완벽하게 끝나려면, 나누어 떨어져야하므로 3으로 최대한 나누고 나머지를 1씩 가져가게끔 계산함. 
- 그러면 카운트가 짝수면 -> 창영이 이기고, 홀수면 -> 상근이 이김. 
- 다른 사람의 풀이를 보니 단순히 n이 홀짝이면 풀리더라...
- 점화식을 세워보면 상근이가 이기는 경우의 수를 가정할 때, 
- 1개 혹은 3개만 가져갈 수 있으므로, 창영이의 선택지는 n-1 혹은 n-3임. 
- 따라서 상근이가 가져갈 수 있는 다음 경우의 수는 n-2, n-4, n-6임. 
- 이렇게 쭉 내려가면 상근이는 n이 홀수일 때 이길 수 있고, 짝수일 때는 창영이가 이기게 됨. 
- 근데 점화식보다 내 풀이가 더 깔끔한 거 같기도...? 어차피 1과 3의 조합이므로... 
'''