'''
N가지 종류의 화폐가 있다. 
이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 
각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 경우는 같은 경우로 구분한다. 

예를 들어 2원, 3원 단위에 화폐가 있을 때는 15원을 만들기위해 3원을 5개 사용하는 것이 가장 최소 개수다.
'''

N, M = map(int, input().split())
coins = []
for _ in range(N):
    coins.append(int(input()))

# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (M + 1)

# 다이나믹 프로그래밍 진행 (Bottom-Up)
d[0] = 0
for i in range(N):
    for j in range(coins[i], M + 1):
        if d[j - coins[i]] != 10001:    # (i - k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j - coins[i]] + 1)

# 계산된 결과 출력
if d[M] == 10001:
    print(-1)
else:
    print(d[M])

'''
회고 / TIL
- 앞 문제 풀어서 자신감을 얻었다가 여기서 대차게 깨졌다. 
- 각 화폐 종류에 대해서 현재 금액 - 화폐 종류 + 1로 점화식을 세워서 푸는 형태다. 
- Top-Down으로 생각했는데, Bottom-Up을 이렇게 구현하다니... 너무 어렵다... 어떻게 저렇게 풀지...
- DP는 여전히 어렵고 갈 길이 멀다. 
'''